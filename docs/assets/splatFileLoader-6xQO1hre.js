import{K as z,e as G,H as N,N as j,U as D,W as H,A as L,L as q,V as F,y as K,c as Z}from"./index-D2CCo2AI.js";var E;(function(A){A[A.Splat=0]="Splat",A[A.PointCloud=1]="PointCloud",A[A.Mesh=2]="Mesh",A[A.Reject=3]="Reject"})(E||(E={}));class S{constructor(a=S._DefaultLoadingOptions){this.name=z.name,this._assetContainer=null,this.extensions=z.extensions,this._loadingOptions=a}createPlugin(a){return new S(a[z.name])}async importMeshAsync(a,r,t,c,n,f){return this._parse(a,r,t,c).then(m=>({meshes:m,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]}))}static _BuildPointCloud(a,r){if(!r.byteLength)return!1;const t=new Uint8Array(r),c=new Float32Array(r),n=3*4+3*4+4+4,f=t.length/n,m=function(x,l){const s=c[8*l+0],o=c[8*l+1],p=c[8*l+2];x.position=new F(s,o,p);const w=t[n*l+24+0]/255,y=t[n*l+24+1]/255,i=t[n*l+24+2]/255;x.color=new K(w,y,i,1)};return a.addPoints(f,m),!0}static _BuildMesh(a,r){const t=new G("PLYMesh",a),c=new Uint8Array(r.data),n=new Float32Array(r.data),f=3*4+3*4+4+4,m=c.length/f,x=[],l=new N;for(let s=0;s<m;s++){const o=n[8*s+0],p=n[8*s+1],w=n[8*s+2];x.push(o,p,w)}if(r.hasVertexColors){const s=new Float32Array(m*4);for(let o=0;o<m;o++){const p=c[f*o+24+0]/255,w=c[f*o+24+1]/255,y=c[f*o+24+2]/255;s[o*4+0]=p,s[o*4+1]=w,s[o*4+2]=y,s[o*4+3]=1}l.colors=s}return l.positions=x,l.indices=r.faces,l.applyToMesh(t),t}_parseSPZ(a,r){const t=new Uint8Array(a),c=new Uint32Array(a),n=c[2],f=t[12],m=t[13];if(t[15]||c[0]!=1347635022||c[1]!=2)return new Promise(e=>{e({mode:3,data:s,hasVertexColors:!1})});const l=3*4+3*4+4+4,s=new ArrayBuffer(l*n),o=1/(1<<m),p=new Int32Array(1),w=new Uint8Array(p.buffer),y=function(e,u){return w[0]=e[u+0],w[1]=e[u+1],w[2]=e[u+2],w[3]=e[u+2]&128?255:0,p[0]*o};let i=16;const V=new Float32Array(s),v=new Float32Array(s),O=new Uint8ClampedArray(s),k=new Uint8ClampedArray(s);for(let e=0;e<n;e++)V[e*8+0]=y(t,i+0),V[e*8+1]=y(t,i+3),V[e*8+2]=y(t,i+6),i+=9;const h=.282;for(let e=0;e<n;e++){for(let u=0;u<3;u++){const b=(t[i+n+e*3+u]-127.5)/(.15*255);O[e*32+24+u]=j.Clamp((.5+h*b)*255,0,255)}O[e*32+24+3]=t[i+e]}i+=n*4;for(let e=0;e<n;e++)v[e*8+3+0]=Math.exp(t[i+0]/16-10),v[e*8+3+1]=Math.exp(t[i+1]/16-10),v[e*8+3+2]=Math.exp(t[i+2]/16-10),i+=3;for(let e=0;e<n;e++){const u=t[i+0],_=t[i+1],b=t[i+2],C=u/127.5-1,I=_/127.5-1,P=b/127.5-1;k[e*32+28+1]=u,k[e*32+28+2]=_,k[e*32+28+3]=b;const U=1-(C*C+I*I+P*P);k[e*32+28+0]=127.5+Math.sqrt(U<0?0:U)*127.5,i+=3}if(f){const u=((f+1)*(f+1)-1)*3,_=Math.ceil(u/16);let b=i;const C=[],P=r.getEngine().getCaps().maxTextureSize,U=Math.ceil(n/P);for(let g=0;g<_;g++){const d=new Uint8Array(U*P*4*4);C.push(d)}for(let g=0;g<n;g++)for(let d=0;d<u;d++){const M=t[b++],B=Math.floor(d/16),R=C[B],W=d%16,T=g*16;R[W+T]=M}return new Promise(g=>{g({mode:0,data:s,hasVertexColors:!1,sh:C})})}return new Promise(e=>{e({mode:0,data:s,hasVertexColors:!1})})}_parse(a,r,t,c){const n=[],f=new ReadableStream({start(l){l.enqueue(new Uint8Array(t)),l.close()}}),m=new DecompressionStream("gzip"),x=f.pipeThrough(m);return new Promise(l=>{new Response(x).arrayBuffer().then(s=>{this._parseSPZ(s,r).then(o=>{const p=new D("GaussianSplatting",null,r,this._loadingOptions.keepInRam);p._parentContainer=this._assetContainer,n.push(p),p.updateData(o.data,o.sh)}),l(n)}).catch(()=>{S._ConvertPLYToSplat(t).then(async s=>{switch(s.mode){case 0:{const o=new D("GaussianSplatting",null,r,this._loadingOptions.keepInRam);o._parentContainer=this._assetContainer,n.push(o),o.updateData(s.data)}break;case 1:{const o=new H("PointCloud",1,r);S._BuildPointCloud(o,s.data)?await o.buildMeshAsync().then(p=>{n.push(p)}):o.dispose()}break;case 2:if(s.faces)n.push(S._BuildMesh(r,s));else throw new Error("PLY mesh doesn't contain face informations.");break;default:throw new Error("Unsupported Splat mode")}l(n)})})})}loadAssetContainerAsync(a,r,t){const c=new L(a);return this._assetContainer=c,this.importMeshAsync(null,a,r,t).then(n=>(n.meshes.forEach(f=>c.meshes.push(f)),this._assetContainer=null,c)).catch(n=>{throw this._assetContainer=null,n})}loadAsync(a,r,t){return this.importMeshAsync(null,a,r,t).then(()=>{})}static _ConvertPLYToSplat(a){const r=new Uint8Array(a),t=new TextDecoder().decode(r.slice(0,1024*10)),c=`end_header
`,n=t.indexOf(c);if(n<0||!t)return new Promise(h=>{h({mode:0,data:a})});const f=parseInt(/element vertex (\d+)\n/.exec(t)[1]),m=/element face (\d+)\n/.exec(t);let x=0;m&&(x=parseInt(m[1]));const l=/element chunk (\d+)\n/.exec(t);let s=0;l&&(s=parseInt(l[1]));let o=0,p=0;const w={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let y;(function(h){h[h.Vertex=0]="Vertex",h[h.Chunk=1]="Chunk"})(y||(y={}));let i=1;const V=[],v=t.slice(0,n).split(`
`);for(const h of v)if(h.startsWith("property ")){const[,e,u]=h.split(" ");i==1?p+=w[e]:i==0&&(V.push({name:u,type:e,offset:o}),o+=w[e]),w[e]||q.Warn(`Unsupported property type: ${e}.`)}else if(h.startsWith("element ")){const[,e]=h.split(" ");e=="chunk"?i=1:e=="vertex"&&(i=0)}const O=o,k=p;return D.ConvertPLYWithSHToSplatAsync(a).then(h=>{const e=new DataView(a,n+c.length);let u=k*s+O*f;const _=[];if(x)for(let d=0;d<x;d++){const M=e.getUint8(u);if(M==3){u+=1;for(let B=0;B<M;B++){const R=e.getUint32(u+(2-B)*4,!0);_.push(R)}u+=12}}if(s)return new Promise(d=>{d({mode:0,data:h.buffer,sh:h.sh,faces:_,hasVertexColors:!1})});let b=0,C=0;const I=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],P=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let d=0;d<V.length;d++){const M=V[d];I.includes(M.name)&&b++,P.includes(M.name)&&C++}const U=b==I.length&&C==3,g=x?2:U?0:1;return new Promise(d=>{d({mode:g,data:h.buffer,sh:h.sh,faces:_,hasVertexColors:!!C})})})}}S._DefaultLoadingOptions={keepInRam:!1};Z(new S);export{S as SPLATFileLoader};
