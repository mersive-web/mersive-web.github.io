import{t as e,V as y,Q as T,l as F,u as b,r as V}from"./index-D2CCo2AI.js";import{G as E,A as M}from"./glTFLoader-Yxyi4Ya7.js";import"./glTFLoaderAnimation-DS5yQamf.js";const n="EXT_mesh_gpu_instancing";class g{constructor(i){this.name=n,this._loader=i,this.enabled=this._loader.isExtensionUsed(n)}dispose(){this._loader=null}loadNodeAsync(i,t,f){return E.LoadExtensionAsync(i,t,this.name,(m,h)=>{this._loader._disableInstancedMesh++;const d=this._loader.loadNodeAsync(`/nodes/${t.index}`,t,f);if(this._loader._disableInstancedMesh--,!t._primitiveBabylonMeshes)return d;const c=new Array;let o=0;const l=a=>{if(h.attributes[a]==null){c.push(Promise.resolve(null));return}const s=M.Get(`${m}/attributes/${a}`,this._loader.gltf.accessors,h.attributes[a]);if(c.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),o===0)o=s.count;else if(o!==s.count)throw new Error(`${m}/attributes: Instance buffer accessors do not have the same count.`)};return l("TRANSLATION"),l("ROTATION"),l("SCALE"),d.then(a=>Promise.all(c).then(([s,p,A])=>{const _=new Float32Array(o*16);e.Vector3[0].copyFromFloats(0,0,0),e.Quaternion[0].copyFromFloats(0,0,0,1),e.Vector3[1].copyFromFloats(1,1,1);for(let r=0;r<o;++r)s&&y.FromArrayToRef(s,r*3,e.Vector3[0]),p&&T.FromArrayToRef(p,r*4,e.Quaternion[0]),A&&y.FromArrayToRef(A,r*3,e.Vector3[1]),F.ComposeToRef(e.Vector3[1],e.Quaternion[0],e.Vector3[0],e.Matrix[0]),e.Matrix[0].copyToArray(_,r*16);for(const r of t._primitiveBabylonMeshes)r.thinInstanceSetBuffer("matrix",_,16,!0);return a}))})}}b(n);V(n,!0,u=>new g(u));export{g as EXT_mesh_gpu_instancing};
